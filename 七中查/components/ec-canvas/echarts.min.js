!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports.echarts=e():t.echarts=e()}(this,(function(){
  function initChart(canvas, theme, opts) {
    const chart = {
      canvas: canvas,
      opts: opts,
      _option: null,
      
      setOption: function(option) {
        this._option = option;
        if (!canvas || !opts) return;

        // 清空画布
        canvas.clearRect(0, 0, opts.width, opts.height);
        
        // 绘制坐标轴
        this.drawAxis(canvas, opts);
        
        // 绘制数据系列
        if (option && option.series) {
          option.series.forEach((series, idx) => {
            if (series.type === 'line' && series.data && series.data.length) {
              this.drawLine(canvas, opts, option.xAxis, series, idx);
            }
          });
        }
      },
      
      drawAxis: function(canvas, opts) {
        // X轴
        canvas.beginPath();
        canvas.setStrokeStyle('#cccccc');
        canvas.moveTo(50, opts.height - 50);
        canvas.lineTo(opts.width - 50, opts.height - 50);
        canvas.lineTo(opts.width - 60, opts.height - 40);
        canvas.moveTo(opts.width - 50, opts.height - 50);
        canvas.lineTo(opts.width - 60, opts.height - 60);
        
        // Y轴
        canvas.moveTo(50, opts.height - 50);
        canvas.lineTo(50, 50);
        canvas.lineTo(40, 60);
        canvas.moveTo(50, 50);
        canvas.lineTo(60, 60);
        
        canvas.stroke();
        
        // 刻度文字
        canvas.setFontSize(10);
        canvas.setFillStyle('#666666');
        canvas.fillText('0', 35, opts.height - 45);
        canvas.fillText('100', 35, 55);
      },
      
      drawLine: function(canvas, opts, xAxis, series, idx) {
        const xData = xAxis.data || [];
        const yData = series.data;
        const xStep = (opts.width - 100) / xData.length;
        const yStep = (opts.height - 100) / 100;
        
        // 绘制折线
        canvas.beginPath();
        canvas.setStrokeStyle(series.lineStyle?.color || ['#2f54eb', '#4cd964', '#ff9500'][idx % 3]);
        canvas.setLineWidth(2);
        
        yData.forEach((val, i) => {
          const x = 50 + i * xStep;
          const y = opts.height - 50 - val * yStep;
          i === 0 ? canvas.moveTo(x, y) : canvas.lineTo(x, y);
          
          // 绘制数据点
          canvas.setFillStyle(canvas.getStrokeStyle());
          canvas.beginPath();
          canvas.arc(x, y, 4, 0, 2 * Math.PI);
          canvas.fill();
          
          // 绘制X轴标签
          if (i % 2 === 0) { // 隔一个显示，避免拥挤
            canvas.setFontSize(10);
            canvas.setFillStyle('#666');
            canvas.fillText(xData[i] || i, x - 15, opts.height - 35);
          }
        });
        
        canvas.stroke();
      },
      
      getOption: function() {
        return this._option;
      }
    };
    
    return chart;
  }

  return {
    init: initChart
  };
}));